require "../core_ext/**"
require "../format"

# MORE `requires` AT THE END

# Common methods shared between the very similar SSA and ASS formats.
module Subtitles
  abstract class Substation < Format
    getter content : IO

    SRT_TIME_FORMAT = "%H:%M:%S.%L"

    # The end-of-line character: '\n' on Unix-like systems, '\r\n' on windows.
    property eol = "\r\n"

    # The below comments are copy-pasted into the ASS and SSA classes as well,
    # please be sure to update all 3 together. Crystal will do this
    # automatically after [#6989](https://github.com/crystal-lang/crystal/pull/6989)
    # is merged.

    # The header for the Styles section. Either [V4 Styles] or [V4+ Styles]
    abstract_class_method styles_section_header
    # The content of the first column of a dialogue row.
    abstract_class_method first_dialogue_column
    # The content of the first column of a format row.
    abstract_class_method first_format_column
    # The default style for subtitles coming from formats without formatting
    # options.
    abstract_class_method default_style
    # The column headers for the default style
    abstract_class_method style_format_columns

    # These initalize methods are shared with the other cousin classes and must
    # be manually maintained to be similar :/

    # initialize with the content
    def initialize(@content : IO); end

    # :ditto:
    def initialize(content string : String)
      @content = IO::Memory.new string
    end

    # Read in an SSA compatible subtitle from the given filepath.
    def initialize(*, filepath : String)
      @content = File.open filepath
    end

    # Build SSA-compatible subtitles from the given `Caption`s.
    def self.new(captions : Captions, eol = "\r\n")
      content = IO::Memory.new
      content << "[Script Info]" << eol
      content << "; Script generated by Subtitles.cr" << eol
      content << "ScriptType: v4.00" << eol
      content << "Collisions: Normal" << eol
      content << eol
      content << styles_section_header << eol
      content << style_format_columns << eol
      content << (style_in?(captions) || default_style) << eol
      content << eol
      content << "[Events]" << eol
      content << "Format: #{first_format_column}, Start, End, Style, Name, MarginL, MarginR, MarginV, Effect, Text" << eol
      captions.reject(&.is_a? Style).as(Array(Caption)).each do |caption|
        content << "Dialogue: #{first_dialogue_column},"
        content << format(time: caption.start) << ","
        content << format(time: caption.end) << ","
        content << "DefaultVCD,NTP,0000,0000,0000,,"
        content << caption.text.gsub(/\r?\n/, "\\N") << eol
      end
      new content.rewind
    end

    private def self.format(time : Time::Span)
      String.build do |s|
        s << time.hours << ':' <<
          time.minutes << ':' <<
          time.seconds << '.'
        s << time.nanoseconds.to_s[0..1]
      end
    end

    # Find the first Style in a list of `Style`s or `Caption`s, and return it.
    # Returns nil when there are no Style elements of the given array.
    private def self.style_in?(captions : Array(Caption | Style)) : Style?
      captions.each do |caption|
        if (found = caption).is_a? Style
          captions.delete found
          return found.as Style
        end
      end
    end

    # Regex values needed to parse Substation subtitles
    module Regexes
      Part           = /^\s*\[([^\]]+)\]\r?\n([\s\S]*)(\r?\n)*$/i
      Line           = /^\s*([^:]+):\s*(.*)(\r?\n)?$/
      Inline         = /\s*,\s*/
      ScriptInfo     = /^\s*\[Script Info\]\r?\n/
      Events         = /\s*\[Events\]\r?\n/
      PositionMarker = /\{\\pos\(\d+,\d+\)\}/
    end

    # The columns the dialogue uses
    property columns = [] of String

    # Apply the parsed regex match to the meta list
    private def parse(meta : Meta, match : Regex::MatchData) : Void
      meta.data[match[1]] = match[2]
    end

    # Separate the fields of the given format line and return it
    private def parse(*, format : String)
      format.split Regexes::Inline
    end

    # Parse a style line and return the Style element
    private def parse_style(string : String, columns : Array(String)) : Style
      style = Style.new
      values = string.split Regexes::Inline
      values.each_with_index do |value, idx|
        style.data[columns[idx]] = value if idx < columns.size
      end
      style
    end

    # Parse the [V4(+) Styles] section
    private def parse(*,
                      styles captions : Array(Caption | Style),
                      match : Regex::MatchData,
                      columns : Array(String)?) : Array(String)?
      name = match[1].strip
      value = match[2].strip
      case name
      when "Format"
        return parse format: value
      when "Style"
        if cols = columns
          captions << parse_style value, cols
        else
          raise StyleBeforeFormat.new content.tell
        end
      end
      nil
    end

    # Parse a line in the dialogue section
    private def parse(*, # require named arguments
                      dialogue captions : Array(Caption | Style),
                      text : String,
                      columns : Array(String)) : Void
      values = text
        .gsub(Regexes::PositionMarker, "")
        .split Regexes::Inline, columns.size
      data = {} of String => String
      columns.each_with_index do |column, idx|
        data[column] = values[idx]? || ""
      end
      captions << Caption.new(
        start: (parse_time data["Start"]),
        end: (parse_time data["End"]),
        content: data["Text"],
        text: data["Text"].gsub("\\N", eol).gsub(/\{[^\}]+\}/, "")
      )
    end

    # Convert this Substation subtitles file to an intermediary format for
    # conversion to another format. This process is lossy. At least all comments
    # will be lost, probably some other information too.
    def to_captions(eol = "\r\n")
      captions = [] of Caption | Style
      meta = nil
      style_columns = nil
      event_columns = nil
      while part = content.gets eol + eol, chomp: true
        lines = part.split(eol).reject { |line| /^\s*;/.match line }.map &.strip
        lines
        tag = lines.shift.delete { |char| ['[', ' ', ']', '\t'].includes? char }
        tag
        lines.each do |line|
          next if /^\s*;/.match line
          if line_match = Regexes::Line.match line
            case tag
            when "ScriptInfo"
              meta ||= Meta.new
              parse meta, line_match
            when "V4Styles", "V4+Styles"
              if cols = parse styles: captions, match: line_match, columns: style_columns
                style_columns = cols
              end
            when "Events"
              name, value = line_match[1].strip, line_match[2].strip
              # puts "parsing event tag #{name}: #{value}"
              case name
              when "Format"
                event_columns = value.split Regexes::Inline
                next
              when "Dialogue"
                if cols = event_columns
                  parse dialogue: captions, text: value, columns: cols
                else
                  raise DialogueBeforeFormat.new content.tell
                end
              end
            else
              Subtitles.logger.debug "Got unrecognized tag #{tag}"
            end
          end
        end
      end
      captions
    end

    # Check that the given content is a Substation filetype
    # Returns `Subtitles::ASS` if the file is a .ass file, `Subtitles::SSA` if
    # it's a .ssa file, an `nil` if it's neither.
    def self.detect(content : String)
      if Regexes::ScriptInfo.match(content)
        if content.includes? "[V4+ Styles]"
          ASS
        else
          SSA
        end
      end
    end

    # :ditto:
    def self.detect(content : IO)
      if (line = content.gets limit: 32) && Regexes::ScriptInfo.match line
        # We have a Substation file (or at least a chunk of memory that looks like one)
        while line = content.gets
          if line.includes? "[V4 Styles]"
            content.rewind
            return SSA
          elsif line.includes? "[V4+ Styles]"
            content.rewind
            return ASS
          end
        end
        content.rewind
      end
      nil
    end

    private def parse_time(string : String) : Time::Span
      time = Time.parse string, SRT_TIME_FORMAT, Time::Location::UTC
      Time::Span.new days: 0, hours: time.hour, minutes: time.minute, seconds: time.second, nanoseconds: time.nanosecond
    end

    # An exception which is raised when the [Format] tag comes physically after
    # the [Style] tag in the file or buffer. When this occurs we have no
    # column in which to place the fields of the recieved row.
    class StyleBeforeFormat < Exception
      def initialize(position)
        super "The [Format] tag must come before [Style]. Found [Style] first at #{position.inspect}"
      end
    end

    # An exception which is raised when the [Format] tag comes physically after
    # the [Dialogue] tag in the file or buffer. When this occurs we have no
    # column in which to place the fields of the recieved row.
    class DialogueBeforeFormat < Exception
      def initialize(position)
        super "The [Format] tag must come before any [Dialogue]. Found [Dialogue] first at #{position.inspect}"
      end
    end
  end
end

require "./ass"
require "./ssa"
